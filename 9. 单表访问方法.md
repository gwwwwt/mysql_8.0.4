# 单表访问方法

> **示例表: **
>
> ```mysql
> mysql> CREATE TABLE single_table (
>     ->     id INT NOT NULL AUTO_INCREMENT,
>     ->     key1 VARCHAR(100),
>     ->     key2 INT,
>     ->     key3 VARCHAR(100),
>     ->     key_part1 VARCHAR(100),
>     ->     key_part2 VARCHAR(100),
>     ->     key_part3 VARCHAR(100),
>     ->     common_field VARCHAR(100),
>     ->     PRIMARY KEY (id),
>     ->     KEY idx_key1 (key1),
>     ->     UNIQUE KEY uk_key2 (key2),
>     ->     KEY idx_key3 (key3),
>     ->     KEY idx_key_part(key_part1, key_part2, key_part3)
>     -> ) Engine=InnoDB CHARSET=utf8;
>     
> Query OK, 0 rows affected (0.03 sec)
> ```
>
> 

## 1. 访问方法的概念

> **MySQL执行查询语句的方式称为访问方法或者访问类型。同一个查询语句可以使用多种不同的访问方法来执行，虽然最后的查询结果都是一样的，但是不同的执行方式花费的时间成本可能差距很大。**



## 2. const

> **在主键列或者唯一二级索引列`与一个常数和进行等值比较`时，MySQL会直接利用`主键值在聚簇索引中定位一条记录`，或类似的，根据`唯一二级索引列`来定位一条记录。`因为最多只有一条记录`，所以这两种方式都是最快的。所以把这种通过主键或者唯一二级索引来定位一条记录的访问方法定义为const。**
>
> > ***`关键字: 主键列或唯一二级索引、常数、等值比较、一条记录`***
>
> ```mysql
> SELECT * FROM single_table WHERE id = 1438;
> 
> SELECT * FROM single_table WHERE key2 = 3841;
> ```
>
> **`注意:`**
>
> + **` 1. 如果主键或者唯一二级索引的索引列由多个列构成，则只有在索引列中的每一个列都与常数进行等值比较时，这个const访问方法才有效。`**
>
> + **`2. 对于唯一二级索引来说，查询列为NULL值时，情况比较特殊。因为唯一二级索引列并不限制NULL值的数量，所以可能访问到多条记录，即对唯一二级索引引查询NULL值时不可以使用const访问方法来执行`**



## 3. ref

> **`"搜索条件为二级索引（非唯一二级索引）列与常数进行等值比较，形成的扫描区间为单点扫描区间，采用二级索引来执行查询" 的访问方法称为ref`**
>
> > ***`关键字: 普通二级索引、常数、等值比较、单点扫描区间`***
>
> **`对于普通二级索引，通过索引列进行等值比较后可能会匹配到多条连续的二级索引记录，而不像主键或者唯一二级索引那样最多只能匹配一条记录，所以 ref访问方法性能比const差`**
>
> ```mysql
> SELECT * FROM single_table WHERE key_part1 = 'god like';
> 
> SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary';
> 
> SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary' ADN key_part3 = 'penta kill';
> ```
>
> 
>
> **`注意:`**
>
> + **`二级索引列允许存储NULL值，所以无论是普通二级索引还是唯一二级索引，它们的索引列并不限制NULL值的数量，所以在执行包含 "KEY is NULL"形式的搜索条件的查询时，最多只能使用ref访问方法，而不能使用const访问方法`**
>
> + **`对于索引列中包含多个列的二级索引来说，只要最左边连续的列是与常数进行等值比较，就可以采用ref访问方法`**
>
> + **`如果索引列中最左边连续的列不全部是等值比较的话，它的访问方法就不能称为ref了，如下所示，`**
>
>   ```mysql
>   # 下面的sql会使用range访问方法
>   SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 > 'legendary';
>   ```
>
>   



## 4. ref_or_null

> **不仅想找出某个二级索引列值等于某个常数的记录，并且还要获取该列中值为NULL的记录，如下sql**
>
> ```mysql
> SELECT * FROM single_table WHERE key1 = 'abc' OR key1 IS NULL;
> ```
>
> **此时如果使用二级索引执行查询时，对应的扫描区间就是 [NULL, NULL] 和 ['abc', 'abc']，此时执行这类查询的访问方法就是 ref_or_null**
>
> > ***`关键字: 比ref访问方法多了一个[NULL, NULL]的扫描区间`***



## 5. range

> **有时sql中的搜索条件很复杂，如下SQL:**
>
> ```mysql
> SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2<= 79);
> ```
>
> > **如果使用idx_key2执行该查询，那么对应的扫描区间就是 [1438, 1438]、[6328, 6328] 、[38, 79]。**
> >
> > **`MySQL中把"使用索引执行查询时，对应的扫描区间为若干个单点扫描区间或者范围扫描区间"的访问方法称为 range，（仅包含一个单点扫描区间的访问方法不能称为 range 扫描方法，扫描区间为 (-∞, +∞) 的访问方法也不能称为range访问方法）`**



## 6. index

> **如下sql:**
>
> ```mysql
> SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
> ```
>
> > **限制: 由于 key_part2 并不是联合索引 idex_key_part 的索引列中最左边的列，所以无法形成合适的范围区间来减少需要扫描的记录数量，从而无法使用 ref 或者 range 访问方法来执行这个语句。**
>
> 
>
> > **但这个查询符合下面两个条件:**
> >
> > + **`它的查询列表只有 key_part1、 key_part2、key_part3 这3个列，而索引 idx_key_part 又恰好包含这3个列`**
> > + **`搜索条件中只有 key_part2 列，这个列也包含在索引 idx_key_part 中`**
>
> > **`即可以直接遍历 idx_key_part 索引的所有二级索引记录，针对获取到的每一条二级索引记录，都判断 key_part2='abc'条件是否成立。如果成立，就从中读取出 key_part1、key_part2、key_part3 这3个列的值并将它们发送给客户端。很显然，在这种使用 idx_key_part 索引执行上述查询的情况下，对应的扫描区间就是 (-♾️, +♾️)。`**
> >
> > **`由于二级索引记录比聚簇索引记录小得多（聚簇索引记录要存储用户定义的所有列以及隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也不用执行回表操作，所以直接扫描全部的二级索引记录比直接扫描全部的聚簇索引记录的成本要小很多。`** ***`Mysql中就把主种扫描全部二级索引记录的访问方法称为 index 访问方法。`***
>
> > **另外，当通过全表扫描对使用InnoDB存储引擎的表执行查询时，如果添加了"ORDER BY主键" 的语句， 那么该语句在执行时也会被人为地认定为使用的是 index 访问方法，如下: **
> >
> > ```mysql
> > SELECT * FROM single_table ORDER BY id;
> > ```



## 7. all

> **全表扫描执行查询的访问方法称为 all访问方法**



## 8. 注意事项

### 8.1 重温二级索引 + 回表

> **在使用索引来减少需要扫描的记录数量时，`一般情况下只会为单个索引生成扫描区间`。如下查询: **
>
> ```mysql
> SELECT * FROM single_table WHERE key1 = 'abc' AND key2 > 1000;
> ```
>
> **这条sql中的两个搜索条件: **
>
> + **key1 = 'abc'，对应的扫描区间就是['abc', 'abc']**
> + **key2 > 1000，地应的扫描区间就是[100, +♾️]**
>
> > **优化器会通过访问表中的少量数据或者直接根据事先生成的统计数据，来计算['abc', 'abc']扫描区间包含多少条记录，再计算[100, +♾️] 扫描区间包含多少条记录，之后再通过一定算法来计算使用这两个扫描区间执行查询时的成本分别是多少，最后选择成本更小的那个扫描区间对应的索引执行查询（有关选择使用哪个索引执行查询的具体步骤，以后再详细说明）**
> >
> > **一般来说，等值查找比范围查找需要扫描的记录数更少（也就是ref访问方法一般比range访问方法好；但这并不总是成立，也有可能在采用ref方法访问时，相应的索引列为特定值的行数特别多）。**
> >
> > **假设优化器决定使用 idx_key1 pfxh来执行查询，那么整个查询的执行过程如下所示: **
> >
> > + **1. 先通过 idx_key1 对应的B+树定位到扫描区间['abc', 'abc']中的第一条二级索引记录**
> > + **2. 根据步骤1中得到的二级索引记录的主键值执行回表操作，得到完整的用户记录，再检测该记录是否满足 key2>1000 条件。如果满足则将其发送给客户端，否则将其忽略**
> > + **3. 再根据该记录所在的单向链表找到下一条二级索引记录，重复步骤2中的操作，直到某条二级索引记录不满足 key1 = 'abc' 条件为止**



### 8.3 索引合并

> **MySQL在"一般情况下"只会为单个索引生成扫描区间，但还存在特殊情况。在这些特殊情况下，MySQL也可能为多个索引生成扫描区间。`MySQL把这种使用多个索引来完成一次查询的执行方法称为 index merge（索引合并）`，具体索引合并方法有3种。**



#### 8.3.1 Intersection 索引合并

> **如下sql:**
>
> ```mysql
> SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
> ```
>
> > **由于搜索条件涉及 key1 和 key3 列，因些可以使用下面两种方案执行该查询: **
> >
> > + **方案1: 使用 idx_key1索引来执行查询，此时对应的扫描区间为['a', 'a']，是一个单点扫描区间。之后回表获取完整记录，之后再判断 key3是否满足条件**
> > + **方案2: 使用 idx_key3 索引执行查询，此时对应的扫描区间就是['b', 'b']。其它操作与方案1类似**
>
> > **`除了全表扫描以及上面提到的2个方案之外， 还有另外一个方案3，具体如下: `**
> >
> > + **方案3: 同时使用 kdx_key1 和 idx_key3 执行查询。`也就是在 idx_key1 中扫描key1值在 ['a', 'a'] 区间中的二级索引记录，同时在 idx_key3 中扫描 key3值在 ['b', 'b'] 区间中的二级索引记录，然后从两者的操作结果中找出 id列值相同的记录（即找出它们共有的 id 值），然后再根据这些共有的 id值执行回表操作， 这样可能省下很多回表操作带来的开销`**
> >
> > > **这里的方案3就是 Intersection索引合并。它指就是对从不同索引中扫描到的记录的 id 值取交集，只为这些 id值执行回表操作。如果使用 Intersection 索引合并的方式执行查询， 并且每个使用到的索引都是二级索引的话，则要求从每个索引中获取到的二级索引记录都是按照主键值排序的。比如上面的查询中，在 idx_key1的['a', 'a']扫描区间中的二级索引记录都是按照主键值排序的，在 idx_key3 的['b', 'b'] 扫描区间中的二级索引记录也都是按照主键值排序的。**
> >
> > > **为什么要求从不同二级索引中获取到的二级索引记录都按照主键值排好序呢? 主要是出于两方面的考虑: **
> > >
> > > + **从两个有序集合中取次比从两个无序集合中取交集要容易得多**
> > > + **如果获取到的id值是有序排列的，则在根据这些id值执行回表操作时就不再是进行单纯的随机I/O（这些id值是有序的），从而会提高效率**
> >
> > 
> >
> > > **假设 idx_key1 的扫描区间 ['a', 'a'] 中二级索引记录的 id 值是排好序的， 且顺序为1、3、5； idx_key3的扫描区间 ['b', 'b'] 中二级索引记录的 id 值也是排好序的，且顺序为 2、3、4，那么这个查询在使用 Intersection 索引合并来执行时，过程如下所示: **
> > >
> > > + **步骤1: 先从 idx_key1 索引的扫描区间 ['a', 'a'] 中取出第一条二级索引记录，该记录的主键值为1 。然后从 idx_key3 索引的扫描区间 ['b', 'b'] 中取出第一条二级索引记录，该记录的主键值为2 。因为 1<2 ，所以直接把从 idx_key1 索引中取出的那条主键值为1 的二级索引记录丢弃**
> > > + **步骤2: 接着继续从 idx_key1 索引的扫描区间 ['a', 'a'] 中取出下一条二级索引记录，该记录的主键值为3 。步骤1中从 idx_key3 索引的扫描区间 ['b', 'b'] 中取出的二级索引记录的主键值为2 。因为 3>2，所以直接把步骤1 中从 idx_key3 索引的扫描区间 ['b', 'b'] 中取出的主键值为2 的那条二级索引记录丢弃**
> > > + **步骤3: 继续上面的步骤，最终获取到主键交集 id = 3 的记录，回表获取完整用户记录后将其发送给客户端**
> >
> > 
> >
> > > **如果在使用某个二级索引执行查询时，从对应的扫描区间中读取出的二级索引记录不是按照主键值排序的，则不可以使用 Intersection索引合并来执行查询，如下查询:**
> > >
> > > ```mysql
> > > SELECT * FROM single_table WHERE key1 > 'a' AND key3 = 'b';
> > > ```



#### 8.3.2 Union 索引合并



#### 8.3.3 Sort-Union 索引合并